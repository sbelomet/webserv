Manager.cpp

/*

# define BUFFER_SIZE 4096

enum ending
{
	BAD_REQUEST = 1,
	END_REQUEST = 2,
	CLOSE_CONNECTION = 3
};

# include <limits>

bool	Manager::epollWaiting( Server &server )
{
	int			index = -1;
	epoll_event	events[MAX_EVENTS];

	int const	ndfs = epoll_wait(server.getEpollFd(), events, MAX_EVENTS, -1);
	if (ndfs < 0)
	{
		perror("epoll_wait");
		throw (Webserv::NoException());
	}
	for (int i = 0; i < ndfs; i++)
	{
		
		if ((events[i].events & EPOLLERR) || (events[i].events & EPOLLHUP)
			|| (!(events[i].events & EPOLLIN)))
		{
			std::cout << "close connection" << std::endl;
			close(events[i].data.fd);
			return (true);
		}
		else if (events[i].data.fd == 0)
		{
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
			return (false);
		}
		else if ((index = server.newConnection(events[i].data.fd)) != -1)
		{
			if (!acceptConnection(server, index))
				return (false);
		}
		else
		{
			readRequest(server, events[i].data.fd);
		}
	}
	return (true);
}

static void	processResponse(Server &server, httpRequest &request, int const &fd,
	int const &socketIndex, int &end)
{
	HttpResponse	response(server.getConfigFromServer(socketIndex), request);
	
	std::vector<int> const	sockets = server.getSockets();
	if (end == END_REQUEST || end == CLOSE_CONNECTION)
	{
		epoll_ctl(server.getEpollFd(), EPOLL_CTL_DEL, fd, NULL);
		close(fd);
		return ;
	}
	else if (end != BAD_REQUEST)
	{
		send(fd, "HTTP/1.1 200 OK\nContent-Type: text/plain; charset=utf-8\nContent-Length: 12\n\nHello world!", 73, 0);
	}
}

void	Manager::readRequest( Server &server, int const &fd )
{
	int			end = 0;
	httpRequest	request;
	int			read_bytes = 0;
	char		buff[BUFFER_SIZE + 1] = {0};
	int const	socketIndex = server.getIndexSocketFromNewConnections(fd);
	
	read_bytes = recv(fd, buff, BUFFER_SIZE, 0);
	if (read_bytes == 0)
		end = CLOSE_CONNECTION;
	else if (read_bytes < 0)
		end = END_REQUEST;
	buff[read_bytes] = 0;
	if (request.parseRequest(buff, read_bytes) == -1)
		end = BAD_REQUEST;
	processResponse(server, request, fd, socketIndex, end);
}

*/

To create a temp file
std::FILE	*tmpFile = std::tmpfile();
	if (tmpFile == NULL)
		throw (Webserv::NoException());

/*

static	std::string	addTimeAndSize( std::string const &name, int const &type )
{
	struct stat	info;
	std::string line;
	std::string	time;
	std::string	size = "-";

	if (stat(name.c_str(), &info) == -1)
		return (std::string(44, ' ') + "-");
	time = ctime(&info.st_mtime);
	time = time.substr(0, (time.size() - 1));
	line = time;
	if (type == DT_REG)
	{
		std::stringstream	ss;
		ss << info.st_size;
		size = ss.str();
	}
	if (size.size() > 21)
		line += size.substr(0, 21);
	else
		line += std::string((21 - size.size()), ' ') + size;
	return (line);
}

static std::string	addEnding( std::string const &name )
{
	std::string		ending;
	size_t	const	space = 52;

	if (name.size() > space)
		ending = name.substr(0, space - 3) + "..></a>";
	else if (name == "..")
		ending = name + "/" + "</a>";
	else
		ending = name + std::string((space - name.size()), ' ') + "</a>";
	return (ending);
}

static std::string	buildLine( std::string const &name, int const &type )
{
	std::string	line;

	// ADD TO REGULAR FILES THE PATH REQUEST
	if (type == DT_DIR)
		line = "<a class=\"directory\" href=\"" + name + "/\">" + addEnding(name);
	else if (type == DT_REG)
		line = "<a class=\"file\" href=\"" + name + "\"/>" + addEnding(name);
	if (name != "..")
		line += addTimeAndSize(name, type);
	line += "\n";
	return (line);
}

static std::string	getDirectories(
	std::map<std::string, int> const &directoryContent)
{
	std::string	line = "";
	std::map<std::string, int>::const_iterator	it;

	for (it = directoryContent.begin(); it != directoryContent.end(); it++)
	{
		if (it->second == DT_DIR)
			line += buildLine(it->first, it->second);
	}
	return (line);
}

static std::string	getRegularFiles(
	std::map<std::string, int> const &directoryContent)
{
	std::string	line = "";
	std::map<std::string, int>::const_iterator	it;

	for (it = directoryContent.begin(); it != directoryContent.end(); it++)
	{
		if (it->second == DT_REG)
			line += buildLine(it->first, it->second);
	}
	return (line);
}

static	bool	getDirectoryContent(std::string const &filePath,
	std::map<std::string, int> &directoryContent )
{
	dirent	*file;
	DIR		*direc;

	direc = opendir(filePath.c_str());
	if (direc == NULL)
	{
		perror("opendir: ");
		return (false);
	}
	while ((file = readdir(direc)) != NULL)
	{
		std::string	name(file->d_name);
		if (name != ".")
		{
			if (file->d_type == DT_DIR)
				directoryContent[name] = DT_DIR;
			else if (file->d_type == DT_REG)
				directoryContent[name] = DT_REG;
		}
	}
	if (closedir(direc) == -1)
	{
		perror("closedir: ");
		return (false);
	}
	return (true);
}

bool	HttpResponse::sendAutoIndex( void )
{
	std::stringstream			ss;
	std::string					body;
	std::string					toSend;
	std::map<std::string, int>	directoryContent;

	if (!getDirectoryContent(getFilePath(), directoryContent))
		throw (Webserv::NoException());
	body = "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<title>Autoindex</title>\n</head>\n<body>\n";
	body += "<h1>Index of " + getPath() + "</h1>\n<section>\n";
	body += getDirectories(directoryContent);
	body += getRegularFiles(directoryContent);
	body += "</section>\n</body>\n</html>";
	ss << body.size();
	getHeader().modifyHeadersMap("Content-Length: ", ss.str());
	toSend = getHeader().composeHeader() + "\n"; // TO REFACTOR ORDER HEADERS
	toSend += body;
	std::cout << toSend << std::endl;
	if (send(getFd(), toSend.c_str(), toSend.size(), 0) < 0)
	{
		perror("send()");
		return (false);
	}
	return (true);
}

*/